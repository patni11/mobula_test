"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui+dom@1.5.4";
exports.ids = ["vendor-chunks/@floating-ui+dom@1.5.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@floating-ui+dom@1.5.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@floating-ui+dom@1.5.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/.pnpm/@floating-ui+core@1.5.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\n\nfunction getCssDimensions(element) {\n    const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width,\n        height,\n        $: shouldFallback\n    };\n}\nfunction unwrapElement(element) {\n    return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(domElement)) {\n        return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const { width, height, $ } = getCssDimensions(domElement);\n    let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.width) : rect.width) / width;\n    let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) {\n        x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n        y = 1;\n    }\n    return {\n        x,\n        y\n    };\n}\nconst noOffsets = /*#__PURE__*/ (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\nfunction getVisualOffsets(element) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)() || !win.visualViewport) {\n        return noOffsets;\n    }\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element)) {\n        return false;\n    }\n    return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {\n                scale = getScale(offsetParent);\n            }\n        } else {\n            scale = getScale(element);\n        }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(domElement);\n        const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(offsetParent) : offsetParent;\n        let currentIFrame = win.frameElement;\n        while(currentIFrame && offsetParent && offsetWin !== win){\n            const iframeScale = getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(currentIFrame).frameElement;\n        }\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)({\n        width,\n        height,\n        x,\n        y\n    });\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { rect, offsetParent, strategy } = _ref;\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    if (offsetParent === documentElement) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent);\n            scale = getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n}\nfunction getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element)).left + (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element).scrollLeft;\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element);\n    const body = element.ownerDocument.body;\n    const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(body).direction === \"rtl\") {\n        x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)();\n        if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === \"viewport\") {\n        rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === \"document\") {\n        rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element));\n    } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(clippingAncestor)) {\n        rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n        const visualOffsets = getVisualOffsets(element);\n        rect = {\n            ...clippingAncestor,\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y\n        };\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element);\n    if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(parentNode)) {\n        return false;\n    }\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(element, [], false).filter((el)=>(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(el) !== \"body\");\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\";\n    let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(currentNode)){\n        const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentNode);\n        const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n            currentContainingBlockComputedStyle = null;\n        }\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\n            \"absolute\",\n            \"fixed\"\n        ].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) {\n            // Drop non-containing blocks.\n            result = result.filter((ancestor)=>ancestor !== currentNode);\n        } else {\n            // Record last containing block for next iteration.\n            currentContainingBlockComputedStyle = computedStyle;\n        }\n        currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const elementClippingAncestors = boundary === \"clippingAncestors\" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.top, accRect.top);\n        accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.right, accRect.right);\n        accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.bottom, accRect.bottom);\n        accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction getDimensions(element) {\n    const { width, height } = getCssDimensions(element);\n    return {\n        width,\n        height\n    };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    const isFixed = strategy === \"fixed\";\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if (isOffsetParentAnElement) {\n            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction getTrueOffsetParent(element, polyfill) {\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\") {\n        return null;\n    }\n    if (polyfill) {\n        return polyfill(element);\n    }\n    return element.offsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n    const window = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {\n        return window;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isTableElement)(offsetParent) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"html\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"body\" && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\" && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(offsetParent))) {\n        return window;\n    }\n    return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(element) || window;\n}\nconst getElementRects = async function(_ref) {\n    let { reference, floating, strategy } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            ...await getDimensionsFn(floating)\n        }\n    };\n};\nfunction isRTL(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).direction === \"rtl\";\n}\nconst platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement,\n    isRTL\n};\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    function cleanup() {\n        clearTimeout(timeoutId);\n        io && io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) {\n            skip = false;\n        }\n        if (threshold === void 0) {\n            threshold = 1;\n        }\n        cleanup();\n        const { left, top, width, height } = element.getBoundingClientRect();\n        if (!skip) {\n            onMove();\n        }\n        if (!width || !height) {\n            return;\n        }\n        const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(top);\n        const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientWidth - (left + width));\n        const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientHeight - (top + height));\n        const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin,\n            threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) {\n                    return refresh();\n                }\n                if (!ratio) {\n                    timeoutId = setTimeout(()=>{\n                        refresh(false, 1e-7);\n                    }, 100);\n                } else {\n                    refresh(false, ratio);\n                }\n            }\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === \"function\", layoutShift = typeof IntersectionObserver === \"function\", animationFrame = false } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(referenceEl) : [],\n        ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    resizeObserver && resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) {\n            resizeObserver.observe(referenceEl);\n        }\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        cleanupIo && cleanupIo();\n        resizeObserver && resizeObserver.disconnect();\n        resizeObserver = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement;\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift;\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip;\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size;\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide;\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow;\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline;\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift;\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */ const computePosition = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZsb2F0aW5nLXVpK2RvbUAxLjUuNC9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaVE7QUFDdE07QUFDZTtBQUNxTjtBQUNqTztBQUU5RCxTQUFTeUMsaUJBQWlCQyxPQUFPO0lBQy9CLE1BQU1DLE1BQU1qQix3RUFBZ0JBLENBQUNnQjtJQUM3Qix5RUFBeUU7SUFDekUseUVBQXlFO0lBQ3pFLElBQUlFLFFBQVFDLFdBQVdGLElBQUlDLEtBQUssS0FBSztJQUNyQyxJQUFJRSxTQUFTRCxXQUFXRixJQUFJRyxNQUFNLEtBQUs7SUFDdkMsTUFBTUMsWUFBWXBCLHFFQUFhQSxDQUFDZTtJQUNoQyxNQUFNTSxjQUFjRCxZQUFZTCxRQUFRTSxXQUFXLEdBQUdKO0lBQ3RELE1BQU1LLGVBQWVGLFlBQVlMLFFBQVFPLFlBQVksR0FBR0g7SUFDeEQsTUFBTUksaUJBQWlCN0IseURBQUtBLENBQUN1QixXQUFXSSxlQUFlM0IseURBQUtBLENBQUN5QixZQUFZRztJQUN6RSxJQUFJQyxnQkFBZ0I7UUFDbEJOLFFBQVFJO1FBQ1JGLFNBQVNHO0lBQ1g7SUFDQSxPQUFPO1FBQ0xMO1FBQ0FFO1FBQ0FLLEdBQUdEO0lBQ0w7QUFDRjtBQUVBLFNBQVNFLGNBQWNWLE9BQU87SUFDNUIsT0FBTyxDQUFDZCxpRUFBU0EsQ0FBQ2MsV0FBV0EsUUFBUVcsY0FBYyxHQUFHWDtBQUN4RDtBQUVBLFNBQVNZLFNBQVNaLE9BQU87SUFDdkIsTUFBTWEsYUFBYUgsY0FBY1Y7SUFDakMsSUFBSSxDQUFDZixxRUFBYUEsQ0FBQzRCLGFBQWE7UUFDOUIsT0FBT2pDLGdFQUFZQSxDQUFDO0lBQ3RCO0lBQ0EsTUFBTWtDLE9BQU9ELFdBQVdFLHFCQUFxQjtJQUM3QyxNQUFNLEVBQ0piLEtBQUssRUFDTEUsTUFBTSxFQUNOSyxDQUFDLEVB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O1lBQ2xCWSxxQkFBcUJFO1FBQ3ZCO0lBQ0Y7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTWhOLGdCQUFnQkMsNERBQWVBO0FBRXJDOzs7O0NBSUMsR0FDRCxNQUFNQyxRQUFRQyxvREFBT0E7QUFFckI7Ozs7O0NBS0MsR0FDRCxNQUFNQyxPQUFPQyxtREFBTUE7QUFFbkI7Ozs7O0NBS0MsR0FDRCxNQUFNQyxPQUFPQyxtREFBTUE7QUFFbkI7Ozs7Q0FJQyxHQUNELE1BQU1DLE9BQU9DLG1EQUFNQTtBQUVuQjs7OztDQUlDLEdBQ0QsTUFBTUMsUUFBUUMsb0RBQU9BO0FBRXJCOzs7O0NBSUMsR0FDRCxNQUFNQyxTQUFTQyxxREFBUUE7QUFFdkI7O0NBRUMsR0FDRCxNQUFNQyxhQUFhQyx5REFBWUE7QUFFL0I7OztDQUdDLEdBQ0QsTUFBTUMsa0JBQWtCLENBQUMySSxXQUFXQyxVQUFVcUI7SUFDNUMsMkVBQTJFO0lBQzNFLHdFQUF3RTtJQUN4RSw2RUFBNkU7SUFDN0UsTUFBTXpELFFBQVEsSUFBSTZGO0lBQ2xCLE1BQU1DLGdCQUFnQjtRQUNwQnREO1FBQ0EsR0FBR2lCLE9BQU87SUFDWjtJQUNBLE1BQU1zQyxvQkFBb0I7UUFDeEIsR0FBR0QsY0FBY3RELFFBQVE7UUFDekJyQixJQUFJbkI7SUFDTjtJQUNBLE9BQU92RyxrRUFBaUJBLENBQUMwSSxXQUFXQyxVQUFVO1FBQzVDLEdBQUcwRCxhQUFhO1FBQ2hCdEQsVUFBVXVEO0lBQ1o7QUFDRjtBQUVvSCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZmxvYXRpbmctdWkrZG9tQDEuNS40L25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLm1qcz8zZjVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBzaGlmdCBhcyBzaGlmdCQxLCBmbGlwIGFzIGZsaXAkMSwgc2l6ZSBhcyBzaXplJDEsIGhpZGUgYXMgaGlkZSQxLCBhcnJvdyBhcyBhcnJvdyQxLCBpbmxpbmUgYXMgaW5saW5lJDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdywgb2Zmc2V0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuaW1wb3J0IHsgcm91bmQsIGNyZWF0ZUNvb3JkcywgbWF4LCBtaW4sIGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGlzSFRNTEVsZW1lbnQsIGlzRWxlbWVudCwgZ2V0V2luZG93LCBpc1dlYktpdCwgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXROb2RlTmFtZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzQ29udGFpbmluZ0Jsb2NrLCBpc1RhYmxlRWxlbWVudCwgZ2V0Q29udGFpbmluZ0Jsb2NrIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5leHBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgLy8gSW4gdGVzdGluZyBlbnZpcm9ubWVudHMsIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIGFyZSBlbXB0eVxuICAvLyBzdHJpbmdzIGZvciBTVkcgZWxlbWVudHMsIHJldHVybmluZyBOYU4uIEZhbGxiYWNrIHRvIGAwYCBpbiB0aGlzIGNhc2UuXG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KSB8fCAwO1xuICBjb25zdCBoYXNPZmZzZXQgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBvZmZzZXRXaWR0aCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggOiB3aWR0aDtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRIZWlnaHQgOiBoZWlnaHQ7XG4gIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gcm91bmQod2lkdGgpICE9PSBvZmZzZXRXaWR0aCB8fCByb3VuZChoZWlnaHQpICE9PSBvZmZzZXRIZWlnaHQ7XG4gIGlmIChzaG91bGRGYWxsYmFjaykge1xuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IHdpbi5mcmFtZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gd2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKS5mcmFtZUVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoICogc2NhbGUueCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogc2NhbGUueSxcbiAgICB4OiByZWN0LnggKiBzY2FsZS54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKiBzY2FsZS54ICsgb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QueSAqIHNjYWxlLnkgLSBzY3JvbGwuc2Nyb2xsVG9wICogc2NhbGUueSArIG9mZnNldHMueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0cyhlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZS5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG4vLyBSZXR1cm5zIHRoZSBpbm5lciBjbGllbnQgcmVjdCwgc3VidHJhY3Rpbmcgc2Nyb2xsYmFycyBpZiBwcmVzZW50LlxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGxldCByZWN0O1xuICBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHJlY3QgPSBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpO1xuICB9IGVsc2UgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICdkb2N1bWVudCcpIHtcbiAgICByZWN0ID0gZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gIH0gZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmVjdCA9IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aXN1YWxPZmZzZXRzID0gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KTtcbiAgICByZWN0ID0ge1xuICAgICAgLi4uY2xpcHBpbmdBbmNlc3RvcixcbiAgICAgIHg6IGNsaXBwaW5nQW5jZXN0b3IueCAtIHZpc3VhbE9mZnNldHMueCxcbiAgICAgIHk6IGNsaXBwaW5nQW5jZXN0b3IueSAtIHZpc3VhbE9mZnNldHMueVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QocmVjdCk7XG59XG5mdW5jdGlvbiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgc3RvcE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmIChwYXJlbnROb2RlID09PSBzdG9wTm9kZSB8fCAhaXNFbGVtZW50KHBhcmVudE5vZGUpIHx8IGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IocGFyZW50Tm9kZSwgc3RvcE5vZGUpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBgb3ZlcmZsb3dgIGVsZW1lbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIGNoaWxkIGVsZW1lbnRzLiBUaGlzIHJldHVybnMgYWxsIGNsaXBwaW5nIGFuY2VzdG9yc1xuLy8gb2YgdGhlIGdpdmVuIGVsZW1lbnQgdXAgdGhlIHRyZWUuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCwgW10sIGZhbHNlKS5maWx0ZXIoZWwgPT4gaXNFbGVtZW50KGVsKSAmJiBnZXROb2RlTmFtZShlbCkgIT09ICdib2R5Jyk7XG4gIGxldCBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gIGNvbnN0IGVsZW1lbnRJc0ZpeGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbiAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIDogZWxlbWVudDtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICB3aGlsZSAoaXNFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlzQ29udGFpbmluZyA9IGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkRHJvcEN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICEhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgJiYgWydhYnNvbHV0ZScsICdmaXhlZCddLmluY2x1ZGVzKGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlLnBvc2l0aW9uKSB8fCBpc092ZXJmbG93RWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBjdXJyZW50Tm9kZSk7XG4gICAgaWYgKHNob3VsZERyb3BDdXJyZW50Tm9kZSkge1xuICAgICAgLy8gRHJvcCBub24tY29udGFpbmluZyBibG9ja3MuXG4gICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGFuY2VzdG9yID0+IGFuY2VzdG9yICE9PSBjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlY29yZCBsYXN0IGNvbnRhaW5pbmcgYmxvY2sgZm9yIG5leHQgaXRlcmF0aW9uLlxuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIGNhY2hlLnNldChlbGVtZW50LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBhbmNlc3RvcnMuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nQW5jZXN0b3JzJyA/IGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLmVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50KSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocG9seWZpbGwpIHtcbiAgICByZXR1cm4gcG9seWZpbGwoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCk7XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgIWlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG5cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChfcmVmKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBnZXRPZmZzZXRQYXJlbnRGbiA9IHRoaXMuZ2V0T2Zmc2V0UGFyZW50IHx8IGdldE9mZnNldFBhcmVudDtcbiAgY29uc3QgZ2V0RGltZW5zaW9uc0ZuID0gdGhpcy5nZXREaW1lbnNpb25zO1xuICByZXR1cm4ge1xuICAgIHJlZmVyZW5jZTogZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQocmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihmbG9hdGluZyksIHN0cmF0ZWd5KSxcbiAgICBmbG9hdGluZzoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICAuLi4oYXdhaXQgZ2V0RGltZW5zaW9uc0ZuKGZsb2F0aW5nKSlcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc1JUTChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG59XG5cbmNvbnN0IHBsYXRmb3JtID0ge1xuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRDbGlwcGluZ1JlY3QsXG4gIGdldE9mZnNldFBhcmVudCxcbiAgZ2V0RWxlbWVudFJlY3RzLFxuICBnZXRDbGllbnRSZWN0cyxcbiAgZ2V0RGltZW5zaW9ucyxcbiAgZ2V0U2NhbGUsXG4gIGlzRWxlbWVudCxcbiAgaXNSVExcbn07XG5cbi8vIGh0dHBzOi8vc2FtdGhvci5hdS8yMDIxL29ic2VydmluZy1kb20vXG5mdW5jdGlvbiBvYnNlcnZlTW92ZShlbGVtZW50LCBvbk1vdmUpIHtcbiAgbGV0IGlvID0gbnVsbDtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgY29uc3Qgcm9vdCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICBpbyAmJiBpby5kaXNjb25uZWN0KCk7XG4gICAgaW8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2goc2tpcCwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHNraXAgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIXNraXApIHtcbiAgICAgIG9uTW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5zZXRUb3AgPSBmbG9vcih0b3ApO1xuICAgIGNvbnN0IGluc2V0UmlnaHQgPSBmbG9vcihyb290LmNsaWVudFdpZHRoIC0gKGxlZnQgKyB3aWR0aCkpO1xuICAgIGNvbnN0IGluc2V0Qm90dG9tID0gZmxvb3Iocm9vdC5jbGllbnRIZWlnaHQgLSAodG9wICsgaGVpZ2h0KSk7XG4gICAgY29uc3QgaW5zZXRMZWZ0ID0gZmxvb3IobGVmdCk7XG4gICAgY29uc3Qgcm9vdE1hcmdpbiA9IC1pbnNldFRvcCArIFwicHggXCIgKyAtaW5zZXRSaWdodCArIFwicHggXCIgKyAtaW5zZXRCb3R0b20gKyBcInB4IFwiICsgLWluc2V0TGVmdCArIFwicHhcIjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZDogbWF4KDAsIG1pbigxLCB0aHJlc2hvbGQpKSB8fCAxXG4gICAgfTtcbiAgICBsZXQgaXNGaXJzdFVwZGF0ZSA9IHRydWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlT2JzZXJ2ZShlbnRyaWVzKSB7XG4gICAgICBjb25zdCByYXRpbyA9IGVudHJpZXNbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAocmF0aW8gIT09IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIWlzRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF0aW8pIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZnJlc2goZmFsc2UsIDFlLTcpO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaChmYWxzZSwgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBhIGBkb2N1bWVudGAgYXMgdGhlIHJvb3QgYW5kIHdpbGwgdGhyb3cgYW5cbiAgICAvLyBlcnJvci5cbiAgICB0cnkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IHJvb3Qub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlvLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmVmcmVzaCh0cnVlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIG5lY2Vzc2FyeS5cbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG1vdW50ZWQgb24gdGhlIERPTSBvclxuICogdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQHJldHVybnMgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9yIGhpZGRlbiBmcm9tIHRoZSBzY3JlZW4uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbCA9IHRydWUsXG4gICAgYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihyZWZlcmVuY2VFbCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZUVsKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfcmVmID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdXBkYXRlIGxvb3BzIHdoZW4gdXNpbmcgdGhlIGBzaXplYCBtaWRkbGV3YXJlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3NDBcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgcmVzaXplT2JzZXJ2ZXIgJiYgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfSk7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmICFhbmltYXRpb25GcmFtZSkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2VFbCk7XG4gICAgfVxuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICB9XG4gIGxldCBmcmFtZUlkO1xuICBsZXQgcHJldlJlZlJlY3QgPSBhbmltYXRpb25GcmFtZSA/IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpIDogbnVsbDtcbiAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgZnJhbWVMb29wKCk7XG4gIH1cbiAgZnVuY3Rpb24gZnJhbWVMb29wKCkge1xuICAgIGNvbnN0IG5leHRSZWZSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSk7XG4gICAgaWYgKHByZXZSZWZSZWN0ICYmIChuZXh0UmVmUmVjdC54ICE9PSBwcmV2UmVmUmVjdC54IHx8IG5leHRSZWZSZWN0LnkgIT09IHByZXZSZWZSZWN0LnkgfHwgbmV4dFJlZlJlY3Qud2lkdGggIT09IHByZXZSZWZSZWN0LndpZHRoIHx8IG5leHRSZWZSZWN0LmhlaWdodCAhPT0gcHJldlJlZlJlY3QuaGVpZ2h0KSkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICAgIHByZXZSZWZSZWN0ID0gbmV4dFJlZlJlY3Q7XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZUxvb3ApO1xuICB9XG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSk7XG4gICAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICAgIH0pO1xuICAgIGNsZWFudXBJbyAmJiBjbGVhbnVwSW8oKTtcbiAgICByZXNpemVPYnNlcnZlciAmJiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGF1dG9QbGFjZW1lbnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gc2hpZnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmbGlwJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IHNpemUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBoaWRlJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gYXJyb3ckMTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gaW5saW5lJDE7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBsaW1pdFNoaWZ0JDE7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4ge1xuICAvLyBUaGlzIGNhY2hlcyB0aGUgZXhwZW5zaXZlIGBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnNgIGZ1bmN0aW9uIHNvIHRoYXRcbiAgLy8gbXVsdGlwbGUgbGlmZWN5Y2xlIHJlc2V0cyByZS11c2UgdGhlIHNhbWUgcmVzdWx0LiBJdCBvbmx5IGxpdmVzIGZvciBhXG4gIC8vIHNpbmdsZSBjYWxsLiBJZiBvdGhlciBmdW5jdGlvbnMgYmVjb21lIGV4cGVuc2l2ZSwgd2UgY2FuIGFkZCB0aGVtIGFzIHdlbGwuXG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsicmVjdFRvQ2xpZW50UmVjdCIsImF1dG9QbGFjZW1lbnQiLCJhdXRvUGxhY2VtZW50JDEiLCJzaGlmdCIsInNoaWZ0JDEiLCJmbGlwIiwiZmxpcCQxIiwic2l6ZSIsInNpemUkMSIsImhpZGUiLCJoaWRlJDEiLCJhcnJvdyIsImFycm93JDEiLCJpbmxpbmUiLCJpbmxpbmUkMSIsImxpbWl0U2hpZnQiLCJsaW1pdFNoaWZ0JDEiLCJjb21wdXRlUG9zaXRpb24iLCJjb21wdXRlUG9zaXRpb24kMSIsImRldGVjdE92ZXJmbG93Iiwib2Zmc2V0Iiwicm91bmQiLCJjcmVhdGVDb29yZHMiLCJtYXgiLCJtaW4iLCJmbG9vciIsImdldENvbXB1dGVkU3R5bGUiLCJpc0hUTUxFbGVtZW50IiwiaXNFbGVtZW50IiwiZ2V0V2luZG93IiwiaXNXZWJLaXQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsImlzT3ZlcmZsb3dFbGVtZW50IiwiZ2V0Tm9kZVNjcm9sbCIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwiZ2V0UGFyZW50Tm9kZSIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImlzQ29udGFpbmluZ0Jsb2NrIiwiaXNUYWJsZUVsZW1lbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJnZXRDc3NEaW1lbnNpb25zIiwiZWxlbWVudCIsImNzcyIsIndpZHRoIiwicGFyc2VGbG9hdCIsImhlaWdodCIsImhhc09mZnNldCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwic2hvdWxkRmFsbGJhY2siLCIkIiwidW53cmFwRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0U2NhbGUiLCJkb21FbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJub09mZnNldHMiLCJnZXRWaXN1YWxPZmZzZXRzIiwid2luIiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwic2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyIsImlzRml4ZWQiLCJmbG9hdGluZ09mZnNldFBhcmVudCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsIm9mZnNldFBhcmVudCIsImNsaWVudFJlY3QiLCJzY2FsZSIsInZpc3VhbE9mZnNldHMiLCJsZWZ0IiwidG9wIiwib2Zmc2V0V2luIiwiY3VycmVudElGcmFtZSIsImZyYW1lRWxlbWVudCIsImlmcmFtZVNjYWxlIiwiaWZyYW1lUmVjdCIsImNsaWVudExlZnQiLCJwYWRkaW5nTGVmdCIsImNsaWVudFRvcCIsInBhZGRpbmdUb3AiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJzdHJhdGVneSIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9mZnNldHMiLCJvZmZzZXRSZWN0IiwiZ2V0Q2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0RG9jdW1lbnRSZWN0IiwiaHRtbCIsImJvZHkiLCJvd25lckRvY3VtZW50Iiwic2Nyb2xsV2lkdGgiLCJjbGllbnRXaWR0aCIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImRpcmVjdGlvbiIsImdldFZpZXdwb3J0UmVjdCIsInZpc3VhbFZpZXdwb3J0QmFzZWQiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvciIsImNsaXBwaW5nQW5jZXN0b3IiLCJoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IiLCJzdG9wTm9kZSIsInBhcmVudE5vZGUiLCJwb3NpdGlvbiIsImdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyIsImNhY2hlIiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwicmVzdWx0IiwiZmlsdGVyIiwiZWwiLCJjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSIsImVsZW1lbnRJc0ZpeGVkIiwiY3VycmVudE5vZGUiLCJjb21wdXRlZFN0eWxlIiwiY3VycmVudE5vZGVJc0NvbnRhaW5pbmciLCJzaG91bGREcm9wQ3VycmVudE5vZGUiLCJpbmNsdWRlcyIsImFuY2VzdG9yIiwic2V0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMiLCJfYyIsImNvbmNhdCIsImNsaXBwaW5nQW5jZXN0b3JzIiwiZmlyc3RDbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdSZWN0IiwicmVkdWNlIiwiYWNjUmVjdCIsInJpZ2h0IiwiYm90dG9tIiwiZ2V0RGltZW5zaW9ucyIsImdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsInBvbHlmaWxsIiwiZ2V0T2Zmc2V0UGFyZW50Iiwid2luZG93IiwiZ2V0RWxlbWVudFJlY3RzIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJnZXRPZmZzZXRQYXJlbnRGbiIsImdldERpbWVuc2lvbnNGbiIsImlzUlRMIiwicGxhdGZvcm0iLCJvYnNlcnZlTW92ZSIsIm9uTW92ZSIsImlvIiwidGltZW91dElkIiwicm9vdCIsImNsZWFudXAiLCJjbGVhclRpbWVvdXQiLCJkaXNjb25uZWN0IiwicmVmcmVzaCIsInNraXAiLCJ0aHJlc2hvbGQiLCJpbnNldFRvcCIsImluc2V0UmlnaHQiLCJpbnNldEJvdHRvbSIsImluc2V0TGVmdCIsInJvb3RNYXJnaW4iLCJvcHRpb25zIiwiaXNGaXJzdFVwZGF0ZSIsImhhbmRsZU9ic2VydmUiLCJlbnRyaWVzIiwicmF0aW8iLCJpbnRlcnNlY3Rpb25SYXRpbyIsInNldFRpbWVvdXQiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImUiLCJvYnNlcnZlIiwiYXV0b1VwZGF0ZSIsInVwZGF0ZSIsImFuY2VzdG9yU2Nyb2xsIiwiYW5jZXN0b3JSZXNpemUiLCJlbGVtZW50UmVzaXplIiwiUmVzaXplT2JzZXJ2ZXIiLCJsYXlvdXRTaGlmdCIsImFuaW1hdGlvbkZyYW1lIiwicmVmZXJlbmNlRWwiLCJhbmNlc3RvcnMiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJjbGVhbnVwSW8iLCJyZW9ic2VydmVGcmFtZSIsInJlc2l6ZU9ic2VydmVyIiwiZmlyc3RFbnRyeSIsInRhcmdldCIsInVub2JzZXJ2ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZnJhbWVJZCIsInByZXZSZWZSZWN0IiwiZnJhbWVMb29wIiwibmV4dFJlZlJlY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiTWFwIiwibWVyZ2VkT3B0aW9ucyIsInBsYXRmb3JtV2l0aENhY2hlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@floating-ui+dom@1.5.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ })

};
;